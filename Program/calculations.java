import java.util.ArrayList;
import java.util.LinkedList;
public class calculations {

/*
 * The calculations class is responsible for creating, removing, sorting and displaying nodes.
 * When you are expanding a node you will get 8 possible states, if you don't reduce the redundant
 * or potentially the same nodes, you will end with massive amount of nodes that you "can" explore.
 * For example if we are trying to create 4 move: 8^4 = 4096 nodes wold be created. This could be us trying to
 * match the centers and bear in mind we haven't even tried solving it.
 * NOTE: calculations does not use history but instead follows a specific path and constantly checks with if and for conditions.
 */

//This will be used when trying to construct a path and to show how many nodes were discovered.
private ArrayList<node> list_of_all_found_nodes = new ArrayList<>();


public void getLIST(){
    System.out.println("Total number of created nodes: "+list_of_all_found_nodes.size());
}



//This method is used in Part (3)
public LinkedList<node> expanding_nodes(node given_node,int[]possible_collection_of_moves) {
    //instead of constantly calling list_of_all_found_nodes.size(). This variable stores it saving some memory.
    int reffernce_to_list_of_all_nodes = list_of_all_found_nodes.size();
    
    LinkedList<node> list_of_final_steps = new LinkedList<>();
    int[] side_one = given_node.getData(0);
    int[] side_two = given_node.getData(1);
    int[] side_three = given_node.getData(2);
    int[] side_four = given_node.getData(3);


    //generated by ChatGPT
    int[][] forgotten = new int[4][];
    for (int k = 0; k < 4; k++) {
        forgotten[k] = given_node.getData(k).clone();
    }
    //generated by ChatGPT

    //loops over all possible moves
    for(int i = 0; i < possible_collection_of_moves.length; i++){

        //gets the move i and looks for that move in case statement below.
        switch (possible_collection_of_moves[i]) {


            //Top gains side 2 (<<< rotation)
            case 0:
                for(int j = 0; j<3;j++){
                    /*Example:
                     * Side (0)     Side(1)     Side(2)
                     * 000000       111111      222222
                     * will be:
                     * 111000       222111      000222
                     */
                    forgotten[0][j] = side_two[j];
                    forgotten[1][j] = side_three[j];
                    forgotten[2][j] = side_one[j];
                }
                list_of_final_steps.add(new node("Node"+i+reffernce_to_list_of_all_nodes,
                                            given_node.name_of_node,
                                            forgotten,
                                            given_node.cost_of_node+1));
            break;


            //Top gains side 3 (>>> rotation)
            case 1:
                for(int j = 0; j<3;j++){
                    forgotten[0][j] = side_three[j];
                    forgotten[1][j] = side_one[j];
                    forgotten[2][j] = side_two[j];
                }
                list_of_final_steps.add(new node("Node"+i+reffernce_to_list_of_all_nodes,
                                                given_node.name_of_node,
                                                forgotten,
                                                given_node.cost_of_node+1));
            break;


            //Right side gains side 2 (<<< rotation)
            case 2:
                for(int j = 0; j<3;j++){
                    if(j+4 != 6){
                    forgotten[0][j+2] = side_two[j+4]; //array length is 0-5, will throw err.
                    forgotten[1][j+4] = side_four[j];
                }else{
                    forgotten[0][j+2] = side_two[0];
                    forgotten[1][0] = side_four[j];
                    
                }
                forgotten[3][j] = side_one[j+2];
                }
                list_of_final_steps.add(new node("Node"+i+reffernce_to_list_of_all_nodes,
                                                given_node.name_of_node,
                                                forgotten,
                                                given_node.cost_of_node+1));
            break;


            //Right side gains side 4(>>> rotation)
            case 3:
                for(int j = 0; j<3;j++){
                    forgotten[0][j+2] = side_four[j];
                    if(j+4 != 6){
                    forgotten[1][j+4] = side_one[j+2];//same here
                    forgotten[3][j] = side_two[j+4];
                }else{
                    forgotten[1][0] = side_one[j+2];
                    forgotten[3][j] = side_two[0];
                }
                }
                list_of_final_steps.add(new node("Node"+i+reffernce_to_list_of_all_nodes,
                                                given_node.name_of_node,
                                                forgotten,
                                                given_node.cost_of_node+1));
            break;


            //Left side gains side 3 (>>> rotation)
            case 4:
                for(int j = 0; j<3;j++){
                    if(j+4 != 6){
                    forgotten[0][j+4] = side_three[j+2];
                    forgotten[2][j+2] = side_four[j+4];
                    forgotten[3][j+4] = side_one[j+4];
                }else{
                    forgotten[0][0] = side_three[j+2];
                    forgotten[2][j+2] = side_four[0];
                    forgotten[3][0] = side_one[0];
                }
                }
                list_of_final_steps.add(new node("Node"+i+reffernce_to_list_of_all_nodes,
                                                given_node.name_of_node,
                                                forgotten,
                                                given_node.cost_of_node+1));
            break;


            //left side gains side 4 (<<< rotation)
            case 5:
                for(int j = 0; j<3;j++){
                    if(j+4 != 6){
                    forgotten[0][j+4] = side_four[j+4];
                    forgotten[2][j+2] = side_one[j+4];
                    forgotten[3][j+4] = side_three[j+2];
                }else{
                    forgotten[0][0] = side_four[0];
                    forgotten[2][j+2] = side_one[0];
                    forgotten[3][0] = side_three[j+2];
                }
                }
                list_of_final_steps.add(new node("Node"+i+reffernce_to_list_of_all_nodes,
                                                given_node.name_of_node,
                                                forgotten,
                                                given_node.cost_of_node+1));
            break;


            // back side >>> right turn
            case 6:
                for(int j = 0; j<3;j++){
                    if(j+4 != 6){
                    forgotten[1][j+2] = side_three[j+4];
                    forgotten[2][j+4] = side_four[j+2];
                }else{
                    forgotten[1][j+2] = side_three[0];
                    forgotten[2][0] = side_four[j+2];
                }
                forgotten[3][j+2] = side_two[j+2];
                }
                list_of_final_steps.add(new node("Node"+i+reffernce_to_list_of_all_nodes,
                                                given_node.name_of_node,
                                                forgotten,
                                                given_node.cost_of_node+1));
            break;


            // back side <<< left turn
            case 7:
                for(int j = 0; j<3;j++){
                    if(j+4 !=6){
                    forgotten[3][j+2] = side_three[j+4];//proper
                    forgotten[2][j+4] = side_two[j+2];//new
                    
                }else{
                    forgotten[3][j+2] = side_three[0];//proper
                    forgotten[2][0] = side_two[j+2];//new
                }
                forgotten[1][j+2] = side_four[j+2];//new
                }
                list_of_final_steps.add(new node("Node"+i+reffernce_to_list_of_all_nodes,
                                                given_node.name_of_node,
                                                forgotten,
                                                given_node.cost_of_node+1));
            break;
        }


    //generated by ChatGPT
    forgotten = new int[4][];
        for (int k = 0; k < 4; k++) {
            forgotten[k] = list_of_final_steps.get(i).getData(k).clone();
    }
    //generated by ChatGPT


    side_one = list_of_final_steps.getLast().data_of_node[0].clone();
    side_two = list_of_final_steps.getLast().data_of_node[1].clone();
    side_three = list_of_final_steps.getLast().data_of_node[2].clone();
    side_four = list_of_final_steps.getLast().data_of_node[3].clone();
    }


    list_of_all_found_nodes.addAll(list_of_final_steps);
    return list_of_final_steps;
    }


/*This method was used in the past, however it was causing an issue as it could of chosen a node that
was essentially a dead end, causing the program to throw an "index out of bounds exception"
because if the node doesn't have any acceptable children for further exploration, 
it's children anlongside itself, get removed.

public node Sort_By_Number_Of_Displaced_Cells(LinkedList<node> given_collection, int[][] refference_node){
    node one_for_keeping = given_collection.get(0);
    for(int i = given_collection.size()-1;i>0;i--){
        if(Side_Sorter(one_for_keeping.data_of_node, refference_node)>
        Side_Sorter(given_collection.get(i).data_of_node, refference_node)){
            one_for_keeping = given_collection.get(i);
        }
    }
    return one_for_keeping;
}

public int Side_Sorter(int[][]given_node, int[][]refference_node){
int counter = 0;
    for(int i = 0; i<4;i++){
    for(int j = 0; j<3;j++){
        if(given_node[i][j*2] != refference_node[i][j*2]){
            counter++;
        }
        }
    }
    return counter;
}
*/


//this method takes array of nodes and a goal state and sorts the array according to 
//how close a node is from the array to the goal state (refference_node)
public LinkedList<node> Sort_By_Base_And_Cost(node refference_node, LinkedList<node> expanding_nodes) {
    node temp_Node = new node();


    for(int j = expanding_nodes.size(); j>0;j--){
        for(int i = 1; i< j;i++){


            //If the node i-1 is less sorted than i, change their positions.
            if(sorter(expanding_nodes.get(i-1).data_of_node, refference_node.data_of_node)<
            sorter(expanding_nodes.get(i).data_of_node, refference_node.data_of_node)){
                temp_Node =  expanding_nodes.get(i-1);
                expanding_nodes.set(i-1,expanding_nodes.get(i));
                expanding_nodes.set(i, temp_Node);
            }


            //if the nodes have the same number of matching sides, check their cost.
            if(sorter(expanding_nodes.get(i-1).data_of_node, refference_node.data_of_node)==
            sorter(expanding_nodes.get(i).data_of_node, refference_node.data_of_node)){
                
                if(expanding_nodes.get(i).cost_of_node <
                expanding_nodes.get(i-1).cost_of_node ){
                    temp_Node =  expanding_nodes.get(i-1);
                    expanding_nodes.set(i-1,expanding_nodes.get(i));
                    expanding_nodes.set(i, temp_Node);
                }
            }
        }
    }

    return expanding_nodes;
}


// takes 2 nodes and compares them returning a number of matching centers.
private int sorter(int[][] given_node, int[][] refference_node){
    int num_of_bases = 0;
    for(int i = 0;i<4;i++){
        for(int j = 0; j<3;j++){
            if(given_node[i][j*2+1]==refference_node[i][j*2+1]){
                num_of_bases++;
            }
        }
    }
return num_of_bases;
}


//checks if all the centers are the same as a refference node
public boolean All_Bases(int[][] givenNode, int[][] refference_node) {
    for(int i = 0; i<givenNode.length;i++){
        for(int j = 0; j<3;j++){
            if(givenNode[i][j*2+1] != refference_node[i][j*2+1]){
                return false;
            }
        }
    }
    return true;
}


/*checks how many edges are correctly placed for the bottom side, for example: 
 * Side (0)     Side(1)
 * 000000       311111
 * Side (0) despite looking correct has its 3rd (0) is in the wrong spot. The correct placement would be:
 * 000000       111111
*/ 
public int Number_Of_Displaced_Corners(int[][] givenNode, int[][] refference_node){
    int num_of_corners = 3;
    for(int i = 0; i<3;i++){
        if(givenNode[3][i*2]==refference_node[3][i*2]){
            if(givenNode[i][4]==refference_node[i][4]){
                num_of_corners--;
            }
        }
    }
    return num_of_corners;
}


//this uses 2 nodes to check the 3rd side and compare how many sides are displaced with the given number
public boolean Correctly_Placed_Sides(int[][] givenNode, int[][] refference_node,
                                        int current_number_of_displaced_sides){
    //here I take given node and check if its sides are where they need to be...
    //e.g. there are multiple blue sides, yet only one can be bordering the red.
    int counter = 3;
    for(int i = 0; i<3; i++){
        if(givenNode[3][i*2]==refference_node[3][i*2]){
            if(refference_node[i][4]==givenNode[i][4]){
                counter--;
            }
        }
    }


    if(counter==current_number_of_displaced_sides){
        return true;
    }

    return false;
}


//this method tries to solve for bottom side ensuring that not only it has correct edges but also that the edges are in the correct place.
public LinkedList<node> Solving_For_Bottom_Side(node given_node, node goal_state) {
    int number_of_displaced_corners = Number_Of_Displaced_Corners(given_node.data_of_node, goal_state.data_of_node);


    LinkedList<node> temp_list_of_nodes = new LinkedList<node>();
    if(number_of_displaced_corners != 0){
        
        //create 64 possible states
        temp_list_of_nodes.addAll(Looking_And_Placing_Edges(given_node, 0, goal_state.data_of_node));
        
        //dead code means that, because I used break on all of my cases in one way or anotherm the i-- never gets called
        for(int i = temp_list_of_nodes.size()-1;i>=0;i--){

            // if the current node has all of its edges in place, remove it (as it made the 2 redundant turns)
                if(temp_list_of_nodes.get(i).data_of_node[3][1]==goal_state.data_of_node[3][1]&&
                temp_list_of_nodes.get(i).data_of_node[3][3]==goal_state.data_of_node[3][3]&&
                temp_list_of_nodes.get(i).data_of_node[3][5]==goal_state.data_of_node[3][5]){
                    temp_list_of_nodes.remove(i);
                    break;
                }

            
            //so, if the 3rd sides edge == to goal of the same edge and the back of that edge is also like goal
            //basically you should be on another side knowing that your side is displaced.
            for(int j = 0; j<3;j++){
                if(temp_list_of_nodes.get(i).data_of_node[3][j*2]==goal_state.data_of_node[3][j*2]&&
                temp_list_of_nodes.get(i).data_of_node[j][4]==goal_state.data_of_node[j][4]){
                    temp_list_of_nodes.remove(i);
                    break;
                }
            }


            //check if the pyraminx or tetraminx has displaced side with 
            //EITHER side 3 and 5 has with the same node as goal
            for(int j = 0; j<3;j++){
                if( i == temp_list_of_nodes.size()){
                    
                    if(i ==0 && temp_list_of_nodes.size()==0){
                        //You should NOT be in this if statement.
                        System.out.println("something is wrong here...");
                    }
                    i--;
                }


                //if base is equal to goal state, check its sides.
                if(temp_list_of_nodes.get(i).data_of_node[j][3]==goal_state.data_of_node[3][j*2+1]){
                    
                    //checking right centers(3) edges(2 and 4)
                    if(j*2+2 != 6){
                        if(temp_list_of_nodes.get(i).data_of_node[j][2] == goal_state.data_of_node[3][j*2]||
                        temp_list_of_nodes.get(i).data_of_node[j][4] == goal_state.data_of_node[3][j*2+2]){
                            break;
                        }
                    }
                    else{
                            if(temp_list_of_nodes.get(i).data_of_node[j][2] == goal_state.data_of_node[3][j*2]||
                            temp_list_of_nodes.get(i).data_of_node[j][4] ==goal_state.data_of_node[3][0]){
                                break;
                            }
                    }
                }


                //5,1,3
                if(temp_list_of_nodes.get(i).data_of_node[j][5]==goal_state.data_of_node[3][Math.abs(5- (j%3 * 4))]){
                    
                    //checking left centers(3) edges(4 and 0)
                    if(j*2+4 < 6){
                        if(temp_list_of_nodes.get(i).data_of_node[j][4] == goal_state.data_of_node[3][j*2+2]||
                        temp_list_of_nodes.get(i).data_of_node[j][0] == goal_state.data_of_node[3][j*2+4]){
                            break;
                        }
                    }else{
                        if(temp_list_of_nodes.get(i).data_of_node[j][4] == goal_state.data_of_node[3][Math.abs(4-(4*j-1))]||
                        temp_list_of_nodes.get(i).data_of_node[j][0] == goal_state.data_of_node[3][-2+2*j]){
                            break;
                        }
                    }
                }
            }

            // if the node did not meet the criteria for the loop above, it is removed.
            temp_list_of_nodes.remove(i);
            break;
        }


        //for the remaining nodes, try and put them back in place
        for(int j = temp_list_of_nodes.size()-1;j>=0;j--){
            temp_list_of_nodes.addAll(Looking_And_Placing_Edges(temp_list_of_nodes.remove(j),  2, goal_state.data_of_node));
        }


        //for all the nodes that remain, check which ones are have more than or equal to number of displaced edges.
        for(int j = temp_list_of_nodes.size()-1;j>=0;j--){
            if(Number_Of_Displaced_Corners(temp_list_of_nodes.get(j).data_of_node, goal_state.data_of_node)>=number_of_displaced_corners){
                temp_list_of_nodes.remove(j);
            }
        }


        //in here we are pruning nodes that are not better than their parent.
        for(int i = temp_list_of_nodes.size()-1; i>=0;i--){
            if(Correctly_Placed_Sides(temp_list_of_nodes.get(i).data_of_node, goal_state.data_of_node, number_of_displaced_corners-1)==false){
                temp_list_of_nodes.remove(i);
            }
        }
    }
    return temp_list_of_nodes;
}

    //this method has similar functionality as expanding_node
public LinkedList<node> Looking_And_Placing_Edges(node given_node ,int iteration_number, int[][] goal_state) {

    //refference instead of constantly calling list_of_all_found_nodes.size()
    int reffernce_to_list_of_all_nodes = list_of_all_found_nodes.size();

    LinkedList<node> array_of_new_nodes = new LinkedList<>();
        int[] side_one = given_node.getData(0);
        int[] side_two = given_node.getData(1);
        int[] side_three = given_node.getData(2);
        int[] side_four = given_node.getData(3);


    for(int i = 0; i < 8; i++){

        //generated by ChatGPT
        int[][] forgotten = new int[4][];
        for (int k = 0; k < 4; k++) {
            forgotten[k] = given_node.getData(k).clone();
        }
        //generated by ChatGPT
            
        switch (i) {
            //First 6 cases (0-5) will be described from first face (0)
            //Top gains side 2 (<<< rotation)
            case 0:
                for(int j = 0; j<3;j++){
                    forgotten[0][j] = side_two[j];
                    forgotten[1][j] = side_three[j];
                    forgotten[2][j] = side_one[j];
                }
                array_of_new_nodes.add(new node("node"+i+reffernce_to_list_of_all_nodes,
                                            given_node.name_of_node,
                                            forgotten,
                                            given_node.cost_of_node+1));
            break;


            //Top gains side 3 (>>> rotation)
            case 1:
                for(int j = 0; j<3;j++){
                    forgotten[0][j] = side_three[j];
                    forgotten[1][j] = side_one[j];
                    forgotten[2][j] = side_two[j];
                }
                array_of_new_nodes.add(new node("node"+i+reffernce_to_list_of_all_nodes,
                                                given_node.name_of_node,
                                                forgotten,
                                                given_node.cost_of_node+1));
            break;


            //Right side gains side 2 (<<< rotation)
            case 2:
                for(int j = 0; j<3;j++){
                    if(j+4 != 6){
                    forgotten[0][j+2] = side_two[j+4]; //array length is 0-5, will throw err.
                    forgotten[1][j+4] = side_four[j];
                }else{
                    forgotten[0][j+2] = side_two[0];
                    forgotten[1][0] = side_four[j];
                    
                }
                forgotten[3][j] = side_one[j+2];
                }
                array_of_new_nodes.add(new node("node"+i+reffernce_to_list_of_all_nodes,
                                                given_node.name_of_node,
                                                forgotten,
                                                given_node.cost_of_node+1));
            break;


            //Right side gains side 4(>>> rotation)
            case 3:
                for(int j = 0; j<3;j++){
                    forgotten[0][j+2] = side_four[j];
                    if(j+4 != 6){
                    forgotten[1][j+4] = side_one[j+2];//same here
                    forgotten[3][j] = side_two[j+4];
                }else{
                    forgotten[1][0] = side_one[j+2];
                    forgotten[3][j] = side_two[0];
                }
                }
                array_of_new_nodes.add(new node("node"+i+reffernce_to_list_of_all_nodes,
                                                given_node.name_of_node,
                                                forgotten,
                                                given_node.cost_of_node+1));
            break;


            //Left side gains side 3 (>>> rotation)
            case 4:
                for(int j = 0; j<3;j++){
                    if(j+4 != 6){
                    forgotten[0][j+4] = side_three[j+2];
                    forgotten[2][j+2] = side_four[j+4];
                    forgotten[3][j+4] = side_one[j+4];
                }else{
                    forgotten[0][0] = side_three[j+2];
                    forgotten[2][j+2] = side_four[0];
                    forgotten[3][0] = side_one[0];
                }
                }
                array_of_new_nodes.add(new node("node"+i+reffernce_to_list_of_all_nodes,
                                                given_node.name_of_node,
                                                forgotten,
                                                given_node.cost_of_node+1));
            break;


            //left side gains side 4 (<<< rotation)
            case 5:
                for(int j = 0; j<3;j++){
                    if(j+4 != 6){
                    forgotten[0][j+4] = side_four[j+4];
                    forgotten[2][j+2] = side_one[j+4];
                    forgotten[3][j+4] = side_three[j+2];
                }else{
                    forgotten[0][0] = side_four[0];
                    forgotten[2][j+2] = side_one[0];
                    forgotten[3][0] = side_three[j+2];
                }
                }
                array_of_new_nodes.add(new node("node"+i+reffernce_to_list_of_all_nodes,
                                                given_node.name_of_node,
                                                forgotten,
                                                given_node.cost_of_node+1));
            break;


            // back side >>> right turn when looking from side one
            case 6:
                for(int j = 0; j<3;j++){
                    if(j+4 != 6){
                    forgotten[1][j+2] = side_three[j+4];
                    forgotten[2][j+4] = side_four[j+2];
                }else{
                    forgotten[1][j+2] = side_three[0];
                    forgotten[2][0] = side_four[j+2];
                }
                forgotten[3][j+2] = side_two[j+2];
                }
                array_of_new_nodes.add(new node("node"+i+reffernce_to_list_of_all_nodes,
                                                given_node.name_of_node,
                                                forgotten,
                                                given_node.cost_of_node+1));
            break;


            // back side <<< left turn when looking from side one
            case 7:
                for(int j = 0; j<3;j++){
                    if(j+4 !=6){
                    forgotten[3][j+2] = side_three[j+4];//proper
                    forgotten[2][j+4] = side_two[j+2];//new
                    
                }else{
                    forgotten[3][j+2] = side_three[0];//proper
                    forgotten[2][0] = side_two[j+2];//new
                }
                forgotten[1][j+2] = side_four[j+2];//new
                }
                array_of_new_nodes.add(new node("node"+i+reffernce_to_list_of_all_nodes,
                                                given_node.name_of_node,
                                                forgotten,
                                                given_node.cost_of_node+1));
            break;
        }
    }


    list_of_all_found_nodes.addAll(array_of_new_nodes);

    //depeiding on the "iteration_number", you will either:

    switch (iteration_number) {

        //explore it again, making 64 nodes from 1
        case 0:
            for(int k = array_of_new_nodes.size()-1; k>=0;k--){
                array_of_new_nodes.addAll(Looking_And_Placing_Edges(array_of_new_nodes.remove(k), iteration_number+1, goal_state));
            }
        break;


        //returning
        case 1:
        break;


        //pruning nodes that have less than 9 centers in place
        case 2:
            for(int i = array_of_new_nodes.size()-1;i>0;i--){
                if(sorter(array_of_new_nodes.get(i).data_of_node, goal_state)<9){
                    array_of_new_nodes.remove(i);
                }
            }


            for(int k = array_of_new_nodes.size()-1; k>=0;k--){
                array_of_new_nodes.addAll(Looking_And_Placing_Edges(array_of_new_nodes.remove(k), iteration_number+1, goal_state));
            }
        break;


        //or pruning nodes that have less than 12 centers in place
        case 3:
            for(int i = array_of_new_nodes.size()-1;i>=0;i--){
                if(sorter(array_of_new_nodes.get(i).data_of_node, goal_state)<12){
                    array_of_new_nodes.remove(i);
                }
            }
        break;
    }


    return array_of_new_nodes;
}


// this method uses node from which it is working backwards trying to make a path
//from initial state, to the "final_node"
public void ConstructPATH(node final_node) {

    ArrayList<node> path_array = new ArrayList<>();
    path_array.add(final_node);

    String refference_node = "";
    refference_node = final_node.parent_of_node;

    for(int i = list_of_all_found_nodes.size()-1;i>-1;i--){
        if(refference_node==list_of_all_found_nodes.get(i).name_of_node){
            path_array.add(list_of_all_found_nodes.get(i));
            refference_node = list_of_all_found_nodes.get(i).parent_of_node;
        }
    }
    How_To_Turn(path_array);
}

//this method uses the constructed path, to display the node
private void How_To_Turn(ArrayList<node> path_array){
    
    System.out.println(path_array.get(path_array.size()-1));
    for(int i = path_array.size()-1; i>0;i--){
        //i-1 is the eleemt we are moving towards.
        Move_From_A_To_B(path_array.get(i-1).data_of_node, path_array.get(i).data_of_node);
        System.out.println(path_array.get(i-1));
    }
}


//this method is telling which turn you need to make to reach the next state.
private void Move_From_A_To_B(int[][] data_of_node, int[][] node) {
        //node is: current state
        //data_of_node is next state
        if(node[0][1]==data_of_node[1][1]){
            System.out.println("Next move is turning top side right >>>");
        }
        if(node[0][1]==data_of_node[2][1]){
            System.out.println("Next move is turning top side left <<<");
        }


        if(node[0][3]==data_of_node[1][5]){
            System.out.println("Next move is turning right side away from you >>>");
        }
        if(node[0][3]==data_of_node[3][1]){
            System.out.println("Next move is turning right side towards you <<<");
        }


        if(node[0][5]==data_of_node[2][3]){
            System.out.println("Next move is turning left side away from you <<<");
        }
        if(node[0][5]==data_of_node[3][5]){
            System.out.println("Next move is turning left side towards you >>>");
        }


        if(node[1][3]==data_of_node[2][5]){
            System.out.println("Next move is turning back side left <<<");
        }
        if(node[1][3]==data_of_node[3][3]){
            System.out.println("Next move is turning back side right >>>");
        }
}


//this adds initial state to lost of all nodes.
public void Add_Initial(node start) {
    this.list_of_all_found_nodes.add(start);
}
}
//Author OlegKov33